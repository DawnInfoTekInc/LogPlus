#LogX filter mapping
#excludes list will be applied first 
#LogX filter urlmapping including list default value is /*
#logx.filter.urlmapping.includes=/*Servlet
#LogX filter urlmapping excluding list default value is 'empty'
#logx.filter.urlmapping.excludes=/*Servlet
logx.header.name=AQALogX
#the keys included must match related fields in logback.xml as well
#The fields which logX preparing the value on run time
#logx.fields=uuid,sessionId,userName,stm-logXId,stm-stepName,remoteIp,hostName
logx.fields=uuid,sessionId,userName,remoteIp,hostName
#the key values carried by the logx header  
#logx.header.includes=uuid,sessionId,userName,stm-logXId,stm-stepName
logx.header.includes=uuid,sessionId,userName
#
# logx custom json layout pattern definition
# 1, reserved keywords: TIMESTAMP, THREAD, LOGGER, LEVEL, MESSAGE, EXCEPTION
# 2, fields default define basic fields which originally exist in logging framework, customized fields are extended fields which need to match with logx fields.
# 3, the format will be "field name [name=you want to print out] [format=special format which originally supported by logging framework](additional: X100 means string will shrink to max chars of 100), [mandatory=if you want it to appear if there's no value on that field]
# 4, by default, all basic (reserved keywords) fields are mandatory
# 5, if there's no specified name, then field name will be printed out
#logx.custom.json.includes=applicationName[Y/appName],serviceName,remoteIp[Y/clientIp],hostName[Y/hostname],processId,uuid[Y/corrId],sessionId,userName[Y/clientId],logMethod,level[Y/logLevel],exception[N]
logx.json.fields.default=TIMESTAMP[name=timestamp][format=yyyy-MM-dd HH:mm:ss.SSS zzz],THREAD,LOGGER,LEVEL[name=logLevel],MESSAGE,EXCEPTION[name=exception][format=X100]
logx.json.fields.custom=applicationName[mandatory=true][name=appName][format=X20],serviceName,remoteIp[name=clientIp],hostName[mandatory=true][name=hostname],processId,uuid[name=corrId],sessionId,userName[name=clientId],Method[name=logMethod]
#Section of key value
# sensitive information need to hide
#cfg.aqa.header.mask=userName
logx.value.hash=userName
#the header key
#if not defined, the key same as prefix
uuid.key=uuid
#Where to find the header value in web entry
#REQUEST_HEADER is a reserved key word, means in the http request
#If request header includes multiple key:value, can be defined as: REQUEST_HEADER.currId[partOne],REQUEST_HEADER.currId[partTwo] ...   
uuid.value=REQUEST_HEADER.uuid,UUID
#Full host name
hostName.key=hostName
#Full host name
hostName.value=HOST_NAME.full
#Host name
#hostName.value=HOST_NAME
#
sessionId.key=sessionId
#SESSION_ID is a reserved key word, means the http sessionID
sessionId.value=SESSION_ID
#SESSION is a reserved key word, means in the http session
userName.value=SESSION.userSession.customerId
# stm use only
#stm-stepName.key=stm-stepName
#stm-logXId.value=REQUEST_HEADER.stm-logXId
#
#stm-stepName.value=REQUEST_HEADER.stm-stepName
#
# REMOTEADDR is a reserved key word, meaning  IP from http request
remoteIp.key=remoteIp
remoteIp.value=REMOTEADDR
#
# ============================================================================
#System Properties
serviceName=SafebankingUIService
applicationName=SafebankingUI
#
#=============================================================================
#Components Implementation
component.CheckPointService=com.dawninfotek.logx.checkpoint.CheckPointServiceBaseImpl
component.EventService=com.dawninfotek.logx.event.EventServiceBaseImpl
component.HashService=com.dawninfotek.logx.security.HashServiceBaseImpl
component.MaskService=com.dawninfotek.logx.security.MaskServiceBaseImpl
#============================================================================
#Resolver
resolver.HOST_NAME=com.dawninfotek.logx.resolver.impl.HostNameResolver
resolver.REQUEST_HEADER=com.dawninfotek.logx.resolver.impl.RequestHeaderResolver
resolver.REMOTEADDR=com.dawninfotek.logx.resolver.impl.RemoteAddrResolver
resolver.UUID=com.dawninfotek.logx.resolver.impl.UUIDResolver
resolver.SESSION_ID=com.dawninfotek.logx.resolver.impl.SessionIdResolver
resolver.SESSION=com.dawninfotek.logx.resolver.impl.SessionValueResolver
#=============================================================================
#Message Section Begin
message.event.begin=%s event %s begin
message.event.end=%s event %s end
message.performance.metric=Performance_Metric:%s, execution time:%s, transactionPath:%s 
#Message Section Begin
#=============================================================================
#Event Names
eventType.application.state.change=Application State Change
eventType.abnormal.condition=Abnormal Condition
eventType.transaction=Transaction
eventType.business=Business
eventType.service=Service
#=============================================================================
#Will use pattern matching if true, otherwise use start-with matching
path.pattern.match=false
#Section of transaction Path Mapping, the path is the 'ServletPath'
txpath.UserLogin=POST::/banking/signonForm.do
txpath.MyProfile=GET::/banking/myProfile.do
#For WebService, header value could be added as parameter, for example:
#txpath.MyProfileSrv=POST::PATH=/bankingSrv/CustomerService::REQUEST_HEADER.soapaction=http://dawninfotek.com/SoapServices/UserProfile
#
#For some applications using for data as to determine the transaction, form data name and value can be defined as:
#txpath.Transter=POST::PATH=/banking/signonForm.do::REQUST_PARAMETER.actionType=InternalAccountTransfer
#  
#=============================================================================
